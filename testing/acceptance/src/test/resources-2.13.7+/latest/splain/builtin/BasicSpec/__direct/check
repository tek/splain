newSource1.scala:13: error: implicit error;
!I e: splain.acceptance.builtin.StaticBasicSpec.ImplicitChain.II
ImplicitChain.g invalid because
!I impPar3: ImplicitChain.I1
――ImplicitChain.i1 invalid because
  !I impPar7: ImplicitChain.I3
  implicitly[II]
            ^
newSource1.scala:6: error: type mismatch;
  splain.acceptance.builtin.StaticBasicSpec.FoundReq.L|splain.acceptance.builtin.StaticBasicSpec.FoundReq.R
  f(new L)
    ^
newSource1.scala:5: error: type mismatch;
  () => scala.Unit|Runnable
  f(3.0, () => println("doesn't work"))
            ^
newSource1.scala:7: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Bounds.F[
    splain.acceptance.builtin.StaticBasicSpec.Bounds.Arg
  ]
Bounds.g invalid because
nonconformant bounds;
[splain.acceptance.builtin.StaticBasicSpec.Bounds.Arg, scala.Nothing]
[A <: Bounds.Base, B]
  implicitly[F[Arg]]
            ^
newSource1.scala:4: error: implicit error;
!I ec: scala.concurrent.ExecutionContext
  Cannot find an implicit ExecutionContext. You might add
  an (implicit ec: ExecutionContext) parameter to your method.

  The ExecutionContext is used to configure how and on which
  thread pools asynchronous tasks (such as Futures) will run,
  so the specific ExecutionContext that is selected is important.

  If your application does not define an ExecutionContext elsewhere,
  consider using Scala's global ExecutionContext by defining
  the following:

  implicit val ec: scala.concurrent.ExecutionContext = scala.concurrent.ExecutionContext.global

  long
  ^
newSource1.scala:10: error: implicit error;
!I e: java.lang.String
f invalid because
!I impPar4:
  List[
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
    )
    ::::
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.Short ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.Short
    )
    ::::
    (
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
      splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
    )
    ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName ::::
    splain.acceptance.builtin.StaticBasicSpec.InfixBreak.VeryLongTypeName
  ]
   (No implicit view available from Int => splain.acceptance.builtin.StaticBasicSpec.InfixBreak.T2.)

  implicitly[String]
            ^
newSource1.scala:11: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.DeepHole.C1[
    splain.acceptance.builtin.StaticBasicSpec.DeepHole.T3[
      splain.acceptance.builtin.StaticBasicSpec.DeepHole.T1[
        List[java.lang.String]
        ,
        ?
      ]
      ,
      splain.acceptance.builtin.StaticBasicSpec.DeepHole.T2[
        splain.acceptance.builtin.StaticBasicSpec.DeepHole.Id
        ,
        splain.acceptance.builtin.StaticBasicSpec.DeepHole.C4
        ,
        ?
      ]
      ,
      ?
    ]
  ]
  implicitly[C1[T3]]
            ^
newSource1.scala:9: error: implicit error;
!I e:
  splain.acceptance.builtin.StaticBasicSpec.Aux.F.Aux[
    splain.acceptance.builtin.StaticBasicSpec.Aux.C
    ,
    splain.acceptance.builtin.StaticBasicSpec.Aux.D
  ]
Aux.f invalid because
!I impPar10: Aux.C
  implicitly[F.Aux[C, D]]
            ^
newSource1.scala:11: error: type mismatch;
  splain.acceptance.builtin.StaticBasicSpec.Refined.A with splain.acceptance.builtin.StaticBasicSpec.Refined.B with splain.acceptance.builtin.StaticBasicSpec.Refined.E|splain.acceptance.builtin.StaticBasicSpec.Refined.C with splain.acceptance.builtin.StaticBasicSpec.Refined.F|<none> {type X = scala.Int|java.lang.String; type Y = java.lang.String; type Z = <none>|java.lang.String}
  f(x)
    ^
newSource1.scala:25: error: type mismatch;
  C.X.Y.T|B.X.Y.T
  f(x: C.X.Y.T)
     ^
newSource1.scala:6: error: type mismatch;
  scala.Int|(=> splain.acceptance.builtin.StaticBasicSpec.Foo.A) => splain.acceptance.builtin.StaticBasicSpec.Foo.B
  f(1: Int)
     ^
newSource1.scala:3: error: type mismatch;
  java.lang.String|Tuple1[java.lang.String]
  val a: Tuple1[String] = "Tuple1": String
                                  ^
newSource1.scala:7: error: implicit error;
!I e: a.type *** b.type
  implicitly[a.type *** b.type]
            ^
newSource1.scala:8: error: implicit error;
!I e: a.type *** b.type
    implicitly[a.type *** b.type]
              ^
newSource1.scala:6: error: implicit error;
!I e: a.type *** b.type
    implicitly[a.type *** b.type]
              ^
newSource1.scala:5: error: implicit error;
!I ev: scala.math.Ordering[java.lang.Object]
  No implicit Ordering[Object] found to build a SortedSet[Object]. You may want to upcast to a Set[Int] first by calling `unsorted`.

Ordering.ordered invalid because
!I asComparable: java.lang.Object => java.lang.Comparable[_$2]
  No implicit view available from Object => Comparable[_ >: Object].

Ordering.comparatorToOrdering invalid because
!I cmp: java.util.Comparator[java.lang.Object]
    ms.map(_ => o)
          ^
newSource1.scala:9: error: implicit error;
!I e: List[splain.acceptance.builtin.StaticBasicSpec.a.TypeA]
   (No implicit view available from Int => splain.acceptance.builtin.StaticBasicSpec.a.TypeA.)

        implicitly[List[TypeA]]
                  ^